## 기본 용어

#### Hoisting(호이스팅)

- 인터프리터가 코드를 실행하기 전에 함수, 변수, 클래스 또는 임포트(import)의 선언문을 해당 범위의 맨 위로 끌어올리는 것처럼 보이는 현상

#### Heap(힙)

- 객체, 배열, 함수와 같이 크기가 동적으로 변할 수 있는 참조타입 값을 저장하는 곳

#### Call stack(콜 스택)

- 원시타입 값과 함수 호출의 실행 컨텍스트를 저장하는 곳

## 타입과 변수/상수

1. undefined는 정의되지 않은걸 뜻하므로 undefined로 정의하는일은 없어야 한다.
2. 배열과 객체는 동등연산자(==)와 일치연산자(===)로 비교해도 false가 나온다.
3. Falsy와 Truthy란 false와 true에 역할을 하는 값
   1. Falsy: 0, Nan, false, null, undefined, ""
   2. Falsy 이외에는 모두 true
4. 대문자 상수란 기억하기 힘든값을 별칭으로 빼서 사용할 경우 사용
   1. 값보다 상수를 이용하는것이 오타를 낼 확률이 낮다. 값보다 상수가 훨씬 유의미하다.
   2. 코드 가독성이 좋아진다.
5. Rest 매개변수
   1. 정해지지 않은 수의 매개변수를 배열로 받는다.
   2. 마지막 매개변수에서만 사용 가능하다.

## Error

1. error를 핸들링 하기 위해 try-catch문을 통해 감싸는데 try는 문제가 발생할 수 있는 로직 catch는 문제에 대한 처리 로직
   > 기본적인 에러는 디버깅과 논리적 구조를 통해 해소해야한다. try-catch문으로 전체 스크립트를 감싸는 일은 코드자체, 성능적으로도 안좋은 습관이다.
2. finaly는 트라이 캐치문 이후에 무조건 동작하기 때문에 주로 리소스 해제,클린업을 위한 코드를 작성한다.

## 배열

#### New Array()

1. 단일 숫자를 넣으면 해당 넓이를 가진 빈 배열을 만든다.
   > New Array(5)

#### Array.of()

1. 대괄호([])로 배열을 만드는 방법보다 성능적으로 떨어지고 장점이 없어 사용하지않는다

#### Array.from()

1. 유사배열이나 이터러블 객체를 배열로 변환해준다.

#### shift()

1. 요소를 하나씩 왼쪽으로 이동
   > 배열 전체를 이동시키기때문에 push나 pop보다 성능적으로 느리다

#### unshift()

1. 요소를 하나씩 오른쪽으로 이동
2. 새로운 요소를 배열의 맨앞쪽에 추가하고, 길이를 반환
   > 배열 전체를 이동시키기때문에 push나 pop보다 성능적으로 느리다

#### slice()

1. begin부터 end(미포함)까지 얕은 복사본을 새로운 배열 객체로 변환
2. 원본 배열은 바뀌지 않는다.

#### concat()

1. 두 개 이상의 배열을 병합하여 새로운 배열을 반환
2. 원본 배열은 바뀌지 않는다

#### find()

1. 배열에서 만족하는 첫번째 요소를 반환

#### map()

1. 함수를 호출한 결과를 모아 새로운 배열을 반환

#### sort()

1. 배열을 정렬하고 정렬한 배열을 반환

#### filter()

1. 주어진 조건에 적합한 얕은 복사본 배열을 반환

#### reduce()

1. 리듀서 함수의 반환 값은 누산기에 할당되고, 누산기는 순회 중 유지되므로 결국 최종 결과는 하나의 값
2. 네개의 인자를 가진다 - 누산기(acc), 현재 값(cur), 현재 인덱스(idx), 원본 배열(src)

## 객체

1. 객체에서 점표기법으로 표현할 수 없는 값은 대괄호 표기법을 사용한다

```
  person = {last name: y, 1: 1, first name: my }
  person.last name - x
  person.first name - x
  person.1 -x
  person["last name"] - o
  person["first name"] - o
  person[1] - o
```

2. key와 value 이름이 같을 경우 생략 가능하다

```
  {
    name: name,
    age: age
  }
  {
    name,
    age
  }
```

3. 객체 구조 분해

```
const o = { p: 42, q: true };
const { p: foo, q: bar } = o;

console.log(foo); // 42
console.log(bar); // true
```

## ✅ 프로토타입(Prototype)

1. 모든 객체는 prototype에 대한 정보를 갖고있다.
2. 생성자에서 접근할때는 prototype, 객체에서 접근할때는 **proto**
3. [[Prototype]]은 사실 접근이 불가능한 객체라 접근을 하기위해 **proto**를 사용한다.

✅ Prototype에 대한 이해가 부족해 다시 한번 학습이 필요

## 이벤트 리스너

1. 이벤트를 등록하는 방법은 3가지가있다.
1. html코드에 직접 삽입 하는방법

```
  <button onclick="clickEvent"/>
```

2. js코드에 직접 이벤트를 적는 방법

```
  document.querySelector("button").onclick = clickEvent;
```

3. addEventListener를 사용하는 방법

```
  document.querySelector("button").addEventListener("click", cliekEvent);
```

- 1번은 HTML코드와 JS코드가 같이있어 유지보수에도 좋지못하고 혼란을가져온다.
- 2번은 이벤트를 한번에 한개만 추가가능하여 권장하지 않는다.
- 3번은 이벤트도 여러개 추가 가능하고 제거도 가능하여 권장한다.

#### 버블링

1. 이벤트가 상위 요소로 전파되는 단계
2. 버블링을 중단하기 위해서는 stopProggation()을 사용해야한다.
   > 꼭 필요한 경우를 제외하고는 버블링을 중단해서는 안된다. why? stopProggation으로 버블링을 막은 영역은 분석이 제대로 되지 않기 때문입니다.

#### 캡처링

1. 이벤트가 하위 요소로 전파되는 단계

## Script

1. 스크립트 파일을 동적으로 추가가 가능하다.
   > 하지만 노출이 쉽게되기때문에 신중하게 사용해야한다.

## 고급함수

#### 순수 함수

1. 입력값이 있고 항상 같은 값을 내는 함수이다.

#### 부수 효과(Side Effect)

1. 함수 내에서 어떤 구현이 함수 외부에 어떤 영향을 끼치는 경우 해당 함수는 Side Effect가 있다고 말한다.

- 순수함수와 비순수함수(Side Effect가 포함된)는 함수명에서 유추 가능하도록 하면 좋다.

#### 팩토리 함수

1. 함수가 객체를 반환할때, 이 함수를 공장 함수 혹은 팩토리 함수라 부른다.

#### 클로저

1. 클로저는 주변 상태에 대한 참조와 함께 묶인 함수의 조합, 즉 클로저는 내부함수에서 외부함수의 범위에 대한 접근을 제공한다.
   > 예제 1과 예제 2는 같은 결과를 만들어낸다.

- 예제 1

```
function init() {
  var name = "my"; // name은 init에 의해 생성된 지역 변수이다.
  function displayName() {
    // displayName() 은 내부 함수이며, 클로저다.
    console.log(name); // 부모 함수에서 선언된 변수를 사용한다.
  }
  displayName();
}
init();
```

- 예제 2

```
function makeFunc() {
  const name = "Mozilla";
  function displayName() {
    console.log(name);
  }
  return displayName;
}

const myFunc = makeFunc();
myFunc();
```

## 동기와 비동기

#### async - await

1. async - 함수앞에 async를 붙이면 Promise를 반환합니다.
2. await - 자바스크립트는 await 키워드를 만나면 프로미스가 처리될 때까지 기다립니다.

#### Promise

1. Promise 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패의 결과 값을 나타냅니다.
2. Promise.race() - Promise.race() 메서드는 Promise 객체를 반환합니다. 이프로미스 객체는 배열에 있는 프로미스중에 가장 먼저 완료된 것의 결과값을 그대로 이행하거나 거부합니다.
3. Promise.all() - Promise.all()은 모든 프로미스가 처리되어야 다음 처리를 진행할 수 있습니다. 하나라도 거부되면 모두 거부됩니다.

## HTTP

#### HEAD

1. HEAD메서드는 GET메서드의 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않는다.

#### OPTIONS

1. 대상 리소스에 대한 통신 가능 옵션을 설명

#### CONNECT

1. 대상 자원으로 식별되는 서버에 대한 터널을 설정

#### TRACE

1. 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

#### GET

1. 리소스 조회

#### POST

1. 요청 데이터 처리, 주로 등록에 사용

#### PUT

1. 리소스를 대체(덮어쓰기), 해당 리소스가 없으면 생성

#### PATCH

1. 리소스 부분 변경(PUT이 전체 변경, PATCH는 일부변경)

#### DELETE

1. 리소스 삭제

## 통신

#### FORM

1. 전체 페이지를 리로드하기 때문에 서버의 부하가 커지고, 시간도 오래 걸린다.
2. 동기 방식으로 페이지가 reload되는 동안에는 다른 데이터를 처리할 수 없다.
3. name을 설정해 줄 경우 데이터 전송이 보다 간편해진다.
4. json데이터를 다루는데 어려움이있다.

#### XHLHttpRequest(XHR)

1. XHR을 사용하면 페이지의 새로고침 없이도 URL에서 데이터를 가져올 수 있습니다. 이를 활용하면 사용자의 작업을 방해하지 않고 페이지의 일부를 업데이트할 수 있습니다.
2. responseType = json을 사용할 경우 굳이 json으로 파싱해줄 필요가 없다.
3. setRequestHeader를 통해 헤더 설정이 가능하다
4. 오래된 브라우저에서 사용이 가능하다(IE)

#### Fetch

1. XHR처럼 비동시 통신 메서드지만 xhr보다 뒤에 나왔으며 대체적으로 더 빠르다
2. Fetch는 프로미스를 다루고 빠르다.
3. 첫번째 인자로 URL 두번째 인자로 옵션을 받는다.

## ✅Export와 Import

#### Export

1. export 문은 JavaScript 모듈에서 함수, 객체, 원시 값을 내보낼 때 사용한다.
2. 내보내는 모듈은 "use strict"의 존재 유무와 상관없이 무조건 엄격 모드이다.

#### Import

1. 정적 import 문은 다른 모듈에서 내보낸 바인딩을 가져올 때 사용한다.
2. 가져오는 모듈은 "use strict"의 존재 유무와 상관없이 무조건 엄격 모드이다.
3. \*을 통해 모듈 전체를 가져올 수 있다.
   > import \* as myModule from "my-module.js"
4. 하나의 멤버만 가져올 수 있다.
   > import {myMember} from "my-module.js"
5. 여러 멤버들을 가져올 수 있다.
   > import {foo, bar} from "my-module.js"
6. as를 통해 별칭을 지정할 수 있다.
   > import {myMember as member} from "my-module.js"

#### globalThis

1. 내보내기 한 모듈의 전역변수를 사용하고 싶을 경우 globalThis.전역변수를 사용하면 된다.
   > globalThis는 전역 스코프의 this를 반환한다

✅ Import Export에 대한 기본 지식은 익혔지만 평상시 쓰지않았기때문에 조금 더 학습 할 필요가 있다.

## 브라우저 저장소

#### 로컬 스토리지(localStorage)

1. 로컬 스토리지는 웹페이지 세션이 끝나도 지워지지않는다
2. 여러 탭이나 창간의 데이터가 서로 공유되며 탭이나 창을 닫아도 데이터는 브라우저에 그대로 남는다.

#### 세션 스토리지(sessionStorage)

1. 세션 스토리지는 웹페이지 세션이 끝날경우 지워진다.
2. 같은 웹사이트를 여러 탭이나 창으로 띄우면 여러개의 세션 스토리지 데이터가 서로격리되어 저장되며 창을 닫을때 데이터도 함께 소멸한다.

#### 쿠키

1. HTTP 쿠키(웹 쿠키, 브라우저 쿠키)는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터이며, 브라우저는 데이터 조각들을 저장해두었다가 동일한 서버에 재 요청 시 저장된 데이터를 함께 전송한다.
2. 목적
   1. 세션 관리(Session management) : 서버에 저장해야 할 로그인, 장바구니, 게임 스코어 등의 정보 관리
   2. 개인화(Personalization) : 사용자 선호, 테마 등의 세팅
   3. 트래킹(Tracking) : 사용자 행동을 기록하고 분석하는 용도
3. 옵션
   1. path=/의 기본값은 현재 경로이고, 설정한 경로나 그 하위 경로에서만 쿠키 정보를 볼 수 있습니다.
   2. domain=site.com 옵션에 아무런 값을 입력하지 않았다면 쿠키를 설정한 도메인에서만 쿠키 정보를 얻을 수 있습니다. 명시적으로 도메인 주소를 설정한 경우엔, 해당 도메인의 서브 도메인에서도 쿠키 정보를 얻을 수 있습니다.
   3. expires/max-age 는 쿠키의 만료 시간을 정해줍니다. 이 옵션이 없으면 브라우저가 닫힐 때 쿠키도 같이 삭제됩니다.
   4. secure 는 HTTPS 연결에서만 쿠키를 사용할 수 있게 합니다.
   5. samesite 는 요청이 외부 사이트에서 일어날 때, 브라우저가 쿠키를 보내지 못하도록 막아줍니다. XSRF 공격을 막는 데 유용합니다.

#### indexDB

1. 너무 많은 복잡한 데이터가 아닌 간단한 데이터를 잠시 브라우저 디비에 저장할때 사용한다.

## 브라우저 지원

1. MDN을 통해 해당 함수가 브라우저에 지원을 하는지 확인할 수 있다.
2. 모든 브라우저를 지원할 수는 없다. 하지만 아래와 같이 해결법이 있다.
   1. 지원할 수 없는 브라우저에는 사용불가하다는 메시지정도만 띄워주는걸로 해소가 될 수 도있다
   2. 폴리필을 통해 지원하지 않는 브라우저에서 사용 할 수 있게해준다.
   3. 코드 트랜스파일링은 최신코드를 구형코드로 바꿔주는 역할을 한다.

## 웹팩과 번들링

#### 번들링

1. 여러 코드와 프로그램들을 묶는 행위
2. 번들링을 하는 이유 why?
   1. 파일의 크기 압축
   2. 원본파일보다 크기가 작아지기때문에 실행 속도, 로딩 속도 또한 빨라진다.
   3. 임의 조작 방지

#### 웹팩

1. 웹 애플리케이션에서 사용하는 수많은 리소스를 하나의 파일로 병합 및 압축해주는 모듈 번들러
2. 웹팩을 사용하는 이유 why?
   1. 파일 단위의 자바스크립트 모듈 관리의 필요성
   2. 웹 애플리케이션의 빠른 로딩속도와 높은 성능

## 라이브러리와 프레임워크

#### 프레임워크

1. 프로그램의 기본구조(뼈대)
2. 프레임워크를 사용하는 이유 why?
   1. 적은 코드 길이
   2. 코드 재사용
   3. 쉬운 디버깅과 애플리케이션 모니터링
   4. 향상된 보안

#### 라이브러리

1. 미리 작성된 코드 그룹으로 작업을 하는데 도움을 줌
2. 라이브러리를 사용하는 이유 why? 1. 개발 속도 증가 2. 안정성 향상
   > 집에 이미 만들어진 가구를 들이는것과 같다.

## ⭐Symbol && Generator && Reflect API && Proxy API

#### Symbol

1. 생성자가 원시 값을 반환하는 내장 객체
2. 고유함이 보장되어 다른코드와 충돌하지 않도록 할 때 많이 쓰인다.
3. 캡슐화, 정보은닉을 제공한다.
4. 매번 호출마다 새로운 심볼이 생성된다.

```
const sym1 = Symbol();
const sym2 = Symbol("foo");
const sym3 = Symbol("foo");
```

#### 제너레이터(Generator)

1. 제너레이터를 만들려면 제너레이터 함수라 불리는 특별한 문법 구조 function\* 이 필요하다.

```
function* generate(){
  yield 1;
  yield 2;
  return 3;
}
```

2. 제너레이터 함수는 일반 함수와 동작 방식이다르다.
   > 제너레이터 함수를 호출하면 코드가 실행되지않고 제네레이터 객체가 반환된다.
3. next()를 호출 하면 가장 가까운 yield문을 만날때까지 실행된다.
   > next()는 value:값, done: 함수실행이 끝났으면 true, 아니면 false를 반환한다.

#### Reflect

1. 객체를 다루는데 도움을 준다.
2. Reflect를 쓰는 이유 why?
   1. 문제가있을때 Object처럼 undefined처리가 아닌 문제를 알려준다.
   2. 더 깔끔한 코드

#### Proxy

1. 객체에 대한 작업을 가로채고 새로 재정의 할 수 있다.
2. 프록시할 원본 객체와 재정의할 객체를 매개변수로 받는다

```
const target = {
  message1: "hello",
  message2: "everyone",
};

const handler1 = {};

const proxy1 = new Proxy(target, handler1);
```

⭐ Javascript 고급 부분이라 확 와닿지않는다. 사용할 기회가있으면 다시한번 공부가 필요하다

## Node.js

1. chrome의 v8엔진을 이용하여 Javascript로 브라우조가 아니라 서버를 구축하고 서버에서 JavaScript가 작동되도록 해주는 런타임 환경(플랫폼)이다.

#### require()

1. require()메서드를 통해 외부 모듈을 가져올 수 있다.

### Event

1. on(event, listener) : 지정한 이벤트의 리스너를 추가
2. once(event, listener) : 지정한 이벤트의 리스너를 추가하지만 한 번 실행한 후에는 자동으로 리스너 제거
3. removeListener(event, listener) : 지정한 이벤트에 대한 리스너를 제거

### Express.js

1. node.js에서 웹서버와 웹애플리케이션을 쉽게 구축하게 도와준다.
   > node.js를 사용하여 쉽게 서버를 구성할 수 있게 만든 클래스와 라이브러리의 집합체

## 보안

1. 민감하고 보안에 중요한 코드는 클라이언트측 코드에 작성해서는 안된다.

#### XSS (Cross Site Scripting)

1. 제 3자가 악성 스크립트를 삽입하여 의도하지 않은 명령을 실행시키거나 세션등을 탈취할 수 있는 취약점이다.
   > 예를들어 url에 <script> </script>를 이용하여 javascript코드를 이용해 정보를 가져올 수 있다.
2. 종류 : Stored XSS, DOM Based XSS, Reflected XSS

#### CSRF (Cross Site Request Forgery)

1. 사이트간 요청 위조
   > 예를들어 피싱 사이트에 접속했을 경우 이미 자동로그인된 Naver, Facebook같은 곳에서 광고성 혹은 유해한 게시글을 업로드한다.

#### CORS (Cross-Origin Resource Sharing)

1. 출처가 다른 리소스를 공유 한다.
   > 예를들어 Naver에 접속하였는데 Naver에서 Naver Pay에 돈을 지불하는 요청을 호출하는 경우
2. 이전 pug파일에서 infinite tree라이브러리를 사용할때 발생해서 iframe으로 대체한 경험이있다.

## 최적화

1. 최적화란 주어진 자원을 더 효율적으로 사용하여 최대 효과를 얻는것

#### 최적화 방법

1. HTML 코드 최적화
   1. inline style을 사용하지않는다
      > 개별적으로 스타일을 주기때문에 렌더링이 느려진다
   2. DOM 트리가 가벼울수록 좋다
      > depth(깊이)가 얕고 복잡하지 않을수록 좋다
2. css 코드 최적화
   1. 사용하지않는 css코드 제거
   2. 간결한 셀렉터 제거
      > 복잡한 셀렉터시 요소를 찾는데 시간이 소요된다.
3. CDN 사용하기
   1. 콘텐츠 전송 네트워크(CDN)는 데이터 사용량이 많은 애플리케이션의 웹 페이지 로드 속도를 높이는 상호 연결된 서버 네트워크
      > 데이터가 전달되기 위해 거쳐야하는 서버의 갯수가 크게 줄기 때문에 로딩 속도가 빨라진다.
4. 캐시 사용하기
   1. 캐시란 다운로드 받은 데이터나 값을 미리 복사해 놓는 임시 장소
      > 같은 데이터를 여러번 요청하게되어 네트워크 리소스를 낭비를 줄여준다.
5. 웹팩과 번들링

## Test

#### Test Runner

1. 테스트 파일을 읽어 작성한 코드를 실행하고, 결과를 출력한다.

#### Testing Framework

1. 사용자가 테스트 코드를 작성할 수 있는 기반을 제공해주는 도구
   > Mocha, Jasmine, AVA등

#### Assertion library

1. 테스트 코드에서 단언(assertion)은 테스트가 통과하기 위한 조건을 명확하게 기술하기 위해 사용

#### 단위테스트

1. 특정 모듈이 의도대로 동작하는지 검증하는 절차다.
2. 함수와 메서드에 대한 테스트 케이스를 작성하는 절차

#### Jest

1. 가장 많이 사용하는 자바스크립트 테스팅 라이브러리
2. 첫번째 매개변수는 테스트의 이름이지만 사실 무슨 동작을하는지 설명을 한다고 보면된다.
3. expect에서 테스트할 함수를 입력한다.
4. toBe와 같은 헬퍼메서드를 통해 결과를 예상한다

```
  test("should add two numbers", () => {
    expect(add(1, 1)).toBe(2);
	expect(add(1, -4)).toBe(-3);
  });
```

#### 통합테스트

1. 모듈들의 상호 작용이 잘 이루어지는지 검증한다.
2. 통합하는 과정에서 발생할 수 있는 오류를 찾는다.

#### E2E (End to End)

1. 사용자 중심으로 처음부터 끝까지 어플리케이션 흐름을 테스트

## 프로그래밍 패러다임

#### 절차지향

- 순차적인 처리를 중요시 여기며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법

1. 장점
   1. 코드의 가독성이 좋다.
   2. 코드를 단위화 할 수 있다.
   3. 컴퓨터의 처리구조와 비슷해 실행 속도가 빠르다
2. 단점
   1. 각각의 코드가 순서에 따라 실행되어, 변경, 유지보수 및 분석이 어렵다.
   2. 변수나 상수 등의 값들을 관리하는 자료형과 해당 자료형을 사용하는 함수가 분리되어 사용된다.

#### 객체지향

- 모든 데이터를 객체로 취급하며, 객체가 처리 요청을 받았을 때, 객체 내부에 있는 기능을 가져와 사용해 처리하는 기법

1. 장점
   1. 코드의 재사용이 가능하다.
   2. 분석과 설계의 전환이 쉽다.
2. 단점
   1. 처리속도가 상대적으로 느리다.
   2. 설계에 많은 시간이 소요된다.
3. 특징
   1. 추상화
   2. 캡슐화
   3. 상속성
   4. 다형성

#### 함수형 프로그래밍

- 순수 함수를 사용해, 상태를 제어하기보다는 빠르게 처리하는데 초점을 둔 방법
  > 실행 순서를 지정할 필요가 없어 비절차형 언어라고도 한다.

1. 장점
   1. 코드에서 프로그램의 실행에 영향을 미치는 영역과 순수한 영역을 최대한 분리한다.
   2. 코드의 가독성이 높아지고, 유지보수가 좋아진다.
   3. 테스트가 쉬워진다.
2. 단점
   1. 외부 데이터 혹은 내부 데이터의 상태를 조작할 수 없다.

## ⭐타입스크립트(TypeScript)

1. 장점
   1. 에러 예방
   2. 실행 속도
   3. 안정성 & 협업용이성
2. 단점
   1. 초기 세팅
   2. 새로운 언어
   3. 더 많은 코드

⭐현재 강의는 JavaScript이기 때문에 TypeScript에 대해서는 간단하게 정리하며 추후 TypeScript만 학습이 필요하다.
